local keys = require "utils.keys"
local hashes = require "utils.hashes"
local settings = require "main.settings"
local druid = require("druid.druid")
local input = require("druid.extended.input")
--local ads = require "utils.ads_sdk"
local data = require "main.data"

local DISPLAY_WIDTH = sys.get_config_int("display.width")
local DISPLAY_HEIGHT = sys.get_config_int("display.height")

local MAX_DELTA = 60
local touch_start_position = nil
local touch_input_mode = false


local function screen_to_world(x, y)
	local w, h = window.get_size()
	local r1 = w / DISPLAY_WIDTH
	local r2 = h / DISPLAY_HEIGHT
	if r1 > r2 then
		x = (x - w / 2) / r2 + DISPLAY_WIDTH / 2
		y = y / r2
	else
		y = (y - h / 2) / r1 + DISPLAY_HEIGHT / 2
		x = x / r1
	end
	return x, y
end


local game_is_on = false
local first_input_done = false

local function first_input()
	if first_input_done then
		return
	end
--	ads.player_interaction()

	first_input_done = true
	gui.set_enabled(gui.get_node("input_preview"), false)
	-- gui.set_enabled(gui.get_node("zoom"), true)
	-- zoom.set_zoom_target(1000)
end

local function is_mobile()
	local sys_info = sys.get_sys_info()
	if sys_info.system_name == "Android" or sys_info.system_name == "iPhone OS" then
		return true
	elseif sys_info.user_agent:find("Android") then
		return true
	elseif sys_info.user_agent:find("iPhone") or sys_info.user_agent:find("iPad") then
		return true
	end
	return false
end

local function transition_game(room_id)
	gui.set_enabled(gui.get_node("input_preview"), true)

	if is_mobile() then
		gui.set_enabled(gui.get_node("joystick_preview"), true)
		gui.animate(gui.get_node("analog1"), "position.x", 60, gui.EASING_INOUTSINE, 4, 0, nil, gui.PLAYBACK_LOOP_PINGPONG)
		gui.animate(gui.get_node("analog1"), "position.y", 20, gui.EASING_OUTSINE, 0.5, 0, function()
			gui.animate(gui.get_node("analog1"), "position.y", -20, gui.EASING_INOUTSINE, 2, 0, nil, gui.PLAYBACK_LOOP_PINGPONG)
		end, gui.PLAYBACK_ONCE_FORWARD)
	else
		gui.set_enabled(gui.get_node("keyboard_preview"), true)
	end
	game_is_on = true

	if settings.local_mode then
		msg.post("/root#main", hashes.CONNECTED_TO_ROOM, {id = room_id})
	end
end

local is_game_over = false



function init(self)
	druid.register("input", input)
	self.druid = druid.new(self)

--	druid_room_id_input = self.druid:new_input("lobby_code_bg", "lobby_code")
	
	gui.set_enabled(gui.get_node("joystick"), false)
	gui.set_enabled(gui.get_node("input_preview"), false)


	if settings.skip_menu then
		transition_game(42)
		--network.create_room(transition_game)
		data.host = true
	end
end

function final(self)
	self.druid:final()
end

function update(self, dt)
	self.druid:update(dt)
end

local function animate_element(icon, from, to, easing, duration, callback)
	to.x, to.y = screen_to_world(to.x, to.y)
	local clone = gui.clone(gui.get_node("animated_element"))
	gui.set_enabled(clone, true)
	gui.set_position(clone, from)
	gui.play_flipbook(clone, icon)
	gui.animate(clone, "position", to, easing, duration, 0, function()
		gui.delete_node(clone)
		if callback then
			callback()
		end
	end)
end

local function set_money(v)
	gui.set_text(gui.get_node("money_text"), tostring(v))
end

local function launch_coin(position)
	local pos_to = gui.get_screen_position(gui.get_node("money_icon"))
	animate_element("coin", position, pos_to, gui.EASING_INOUTSINE, 1, nil)
end

local function on_layout_change()
	if game_is_on and not first_input_done then
		gui.set_enabled(gui.get_node("input_preview"), true)
	else
		gui.set_enabled(gui.get_node("input_preview"), false)
		-- gui.set_enabled(gui.get_node("zoom"), true)
	end
	gui.set_enabled(gui.get_node("joystick"), false)
end

function on_message(self, message_id, message, sender)
	self.druid:on_message(message_id, message, sender)
	
	if message_id == hashes.SET_MONEY then
		set_money(message.value)
	elseif message_id == hashes.LAUNCH_COIN then
		launch_coin(message.position)
	end

	if message_id == hash("layout_changed") and message.id == hash("Landscape") then
		on_layout_change()
	elseif message_id == hash("layout_changed") and message.id == hash("Portrait") then
		on_layout_change()
	elseif message_id == hashes.INPUT_DONE then
		first_input()
	end
end


function on_input(self, action_id, action)
	self.druid:on_input(action_id, action)

	if action_id == keys.TOUCH then
		if settings.enable_touch_input and game_is_on then
			local touch_position = vmath.vector3(action.x, action.y, 0)
			if action.pressed then
				first_input()
				touch_input_mode = true
				touch_start_position = touch_position
				gui.set_enabled(gui.get_node("joystick"), true)
				local v = vmath.vector3()
				local w, h = window.get_size()
				v.x = touch_start_position.x / (DISPLAY_WIDTH/w)
				v.y = touch_start_position.y / (DISPLAY_HEIGHT/h)
				gui.set_screen_position(gui.get_node("joystick"), v)
			elseif action.released then
				touch_input_mode = false
				gui.set_enabled(gui.get_node("joystick"), false)
				msg.post("/root#main", hash("screen_input"), {delta = vmath.vector3()})
				touch_start_position = nil
			elseif touch_input_mode then
				local delta = touch_position - touch_start_position
				local w, h = window.get_size()
				delta.x = delta.x / (DISPLAY_WIDTH/w)
				delta.y = delta.y / (DISPLAY_HEIGHT/h)
				local length = vmath.length(delta)
				if length > MAX_DELTA then
					delta = vmath.normalize(delta) * MAX_DELTA
				end
				gui.set_position(gui.get_node("analog"), delta)
				delta = delta / MAX_DELTA
				msg.post("/root#main", hash("screen_input"), {delta = delta})
			end
		end
	elseif action_id == keys.DOWN then
		first_input()
		if action.pressed or action.released then
			msg.post("/root#main", keys.DOWN, {pressed = action.pressed})
		end
	elseif action_id == keys.LEFT then
		first_input()
		if action.pressed or action.released then
			msg.post("/root#main", keys.LEFT, {pressed = action.pressed})
		end
	elseif action_id == keys.RIGHT then
		first_input()
		if action.pressed or action.released then
			msg.post("/root#main", keys.RIGHT, {pressed = action.pressed})
		end
	elseif action_id == keys.UP then
		first_input()
		if action.pressed or action.released then
			msg.post("/root#main", keys.UP, {pressed = action.pressed})
		end
	end
end